---
layout: default
title: The Day-to-Day
---
Scott Koon recently wrote a great article, [Pros Don’t Make Do](http://www.lazycoder.com/weblog/2009/11/23/pros-dont-make-do/). Scott argues that in order to be a true professional, you have to use the right tool for the job.

I agree entirely. Rarely is there one silver-bullet solution to every software problem. No language, framework, or toolset is appropriate to every situation, but numerous software shops assume the opposite. Many software developers are or have been in such "one-size-fits-all" organizations. Is there a reason in these places to study tools and frameworks you may not be able to use right here, right now?

Expanding your repertoire carries long-term benefits to your career, but hardly impacts the day-to-day. However, there are less obvious and more immediate benefits to such knowledge too. Learning a toolset doesn't just add to your base of knowledge, it changes the way you write software. It goes back to the idea of "programming into a language" rather than "programming in a language" to borrow from [Steve McConnell’s Code Complete](http://www.amazon.com/gp/product/0735619670). McConnell argues that your code should ultimately not be constrained by the choice of language or toolset.

Writing such code is only possible by either being a super-genius, or by expanding your knowledge of tools and technologies. Perhaps a concrete example will help. Last week I, along with another .NET developer from a different company, attended a meeting of the [Chicago Area Scala Enthusiasts](http://www.meetup.com/chicagoscala/) about making Domain-Specific Languages with Scala, via [Dave Orme](http://www.coconut-palm-software.com/).

Neither of us will ever, EVER have a chance to use Scala in our current jobs. However, all we could talk about after the meeting was how Dave's use of implicit conversions in Scala to create DSLs changed how we viewed C#'s extension methods.

Whereas before we have viewed extension methods as mainly a way to add missing convenience methods to pre-built classes, now we saw them as a useful method to change the entire meaning of constants and classes, to build basic DSLs out of primitives and constants in .NET.

I have similar stories about Ruby's method_missing, aspect oriented programming, and pair programming, to name a few off the top of my head. All of these have provided opportunities to rethink how I'm writing code independently of these technologies.

Of course your mileage may vary. If you decide you have nothing to gain in the day-to-day from learning an alien language or unfamiliar toolset, you are destined to be proved correct regardless. If instead you approach such opportunities with an open mindset, you may be surprised at what new thoughts and ideas trickle in.

Or if you are like me, you’ll be pleasantly surprised when anything whatsoever manages to trickle in.
-Scott